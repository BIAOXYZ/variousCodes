条件表达式 expr1 ? expr2 : expr3 的求值次序为什么是“从右至左”？不是先算expr1，然后根据结果算expr2或者expr3吗。

=========================Chapter2分割线=========================

p30 “内部名字（ internal name）的至少前 31 个字符是有效的。对于函数名和外部变量来说，
名字的字符数量可能会少于 31 个，因为外部名字（ external name）可能会被语言无法控制
的汇编器和加载器所使用。对于外部名字， ANSI 标准只保证前六个字符的唯一性且不区分大小
写。像 if、 else、 int、 float 等关键字都是保留的：你不能够将它们用作变量名。关键字
使用的必须是小写字母。”
(http://segmentfault.com/q/1010000000339403)现在已经没有这个限制了

p31 “未限定的 char 型变量是有符号（signed）还是无符号（unsigned）取决于具体机器，但是可打印字符一定是正值。”

p32 首次提到标准头文件 <limits.h> 和 <float.h>。 

p31 “例如，在 ASCII 字符集中，字符常量’0’的值为 48――与数值 0 毫无关系。如果代码使用字符’0’而不是使用 48 这样依赖于字符集的数值，那么程序将会独立于特定的值并且更易阅读。虽然字符常量主要用来与另外的字符进行比较，但也可以像其他任何整数一样参与数值运算。”

p32 “字符常量’\0’表示一个值为 0 的字符，即空字符。我们常使用’\0’来替代 0 以强调某些
表达式的字符性质，但其数值就是 0。”

p33 首次提到标准头文件 <string.h> ，以及其中的strlen函数。

p33 “枚举提供了一种将常量值和名字关联起来的便利方法。作为#define 语句的另一选择，其优点在于常量的值可以自动生成。虽然可以声明 enum 类型的变量，但编译程序不需要检查在这个变量中存储的值是否是该枚举的有效值；不过枚举变量提供了进行这种检查的机会，因而常常比使用#define 更好。此外，调试程序还能以符号形式打印出枚举变量的值。”

p34 首次出现关于const的内容。

p34 “更加有趣的是逻辑运算符 && 和 || 。以 && 或 || 连接的表达式按从左至右的次序求值，一旦获知结果的真假，求值过程就会立即终止。许多C程序依赖于这样的特性。”

p36 首次提到标准头文件 <ctype.h>，以及其中的tolower函数和isdigit函数。

p36 “为了程序的可移植性，如果打算将非字符数据存放在 char 型变量中，请指定 signed 或 unsigned 类型。”

p36 “因此下面的赋值d = c >= ‘0’ && c <= ‘9’当 c 是数字时将 d 置为 1，否则置为 0。然而， isdigit 等函数却会返回任意的非零值表示真。在 if、 while、 for 等语句的测试部分，“真”仅意味着“非零”，因此两者不会造成差别。”

p37 首次提到<math.h>。然后在页末提到了sqrt函数。
“通常，像那些在 <math.h> 中的数学函数会使用双精度（即 double）。使用 float 的主要原因是为了节省大型数组的存储空间，较少些的原因是为了节省某些双精度运算代价特高的机器的运行时间。”

p37 关于有符号和无符号型的比较（http://stackoverflow.com/questions/25054477/clarity-of-1l-1u-and-1l-1ul）
“例如， 假定 int 为 16 位， long 为 32 位，那么-1L < 1U，这是因为 unsigned int 型的 1U 被提升为 signed long 类型；但是 -1L > 1UL，这是因为-1L 被提升为 unsigned long 类型，这样它就变成了一个大的正数。”
另外p157页A.6.2那里也有解释。

p37 “因而，如果 n 是一个整数，那么可以用sqrt((double )n)将 n 的值转换成 double 型之后再传递给 sqrt。注意，强制类型转换只是按恰当类型产生 n的值， n 本身并未被修改。”

p38 首次提到标准库中的rand函数和srand函数。

p38 “递增和递减运算符只能作用于变量；像 (i+j)++ 这样的表达式是不合法的。”

p39 首次提到标准库函数 strcat。

p41 “如果 expr1 和 expr2 是表达式，那么 expr1 op= expr2 相当于 expr1 = (expr1) op (expr2) 只是前者的 expr1 仅会被计算 1 次。留意 expr2 周围的括号：x *= y + 1 表示 x = x * (y + 1) 而不是 x = x * y + 1”

p42 “在所有这类表达式中，赋值表达式的类型是它左操作数的类型，它的值则等于赋值完成后
的值。”

p42 “如果 expr2 和 expr3 是不同的类型，结果的类型依照本章先前讨论的转换规则确定。例如，如果 f 是 float 型而 n 是 int 型，那么表达式 (n > 0) ? f : n 无论 n 是否为正，其类型都为 float。”


=========================Chapter2分割线=========================

page32-33 就是给了个实现和strlen()等价的子程序，就不改写运行了吧。反正很显然的。――最后还是写了。。。

