/* 练习 1-10. 写一个程序，将输入拷贝到输出，将每个制表符替换为\t，将每个空格替换为\b，
将每个反斜杠替换为\\。这使得制表符和空格能够被明确地分辨出来。*/

/*
#include <stdio.h>

int main()
{
    int c;
    while ( (c = getchar()) != EOF ){
        if (c == '\t')
            printf("\\t");  //最开始这句写成了"printf("\t");"，错误很明显了。输出到屏幕上的还是个制表符。只有先用第一个反斜杠让第二个反斜杠失效才行。
        else if (c == ' ')
            printf("\\b");
        else if ( c == '\\')
            printf("\\\\");
        else
            putchar(c);
    }
    return 0;
}
*/

/* 用for循环实现的 */

// /*
#include <stdio.h>

int main()
{
    int c;
    for ( ;(c = getchar()) != EOF; c = getchar()){
    /* 如果用上面那句代替下面那个for语句会有些小问题，不过没有细看。回来再研究吧。*/

    /* （http://bbs.csdn.net/topics/391837490）大致的答案在这里了，但仍不完全准确：*/
    /*
    for（表达式1；表达式2；表达式3）
    {
    语句1；
    }
    //表达式2，表达式3每次都会执行，所以每次循环执行了两遍c = getchar()
    */

    /* 为什么我说不完全准确呢，原因是，上面的程序大致是这样的：
    输入1回车，测试1不是EOF，于是输出1。
    输入12回车，测试1不是EOF，输出1，但c变成了2，然后又变成了回车，最终输出
        1\n。
    输入1234，测试1不是EOF，输出1，c变为2；但紧接着的输入3又把c变成3去测试，
        依然不等于EOF，输出3，但再一次的输入4把c变成了4，最后输入回车去测试，
        回车也不是EOF，最终的输出是13\n。

    此时出现问题了。如果我接着在后面输入1234回车，会显示24；但是如果再按一次回车
    换一个新行输入1234回车，依然是13\n。
    */

    /* 准确解释如下（http://segmentfault.com/q/1010000003814461）。其实是由于c=getchar()
    这句会等待输入。*/
    /*
    你的输入：1234回车
    第1遍循环：取到1并输出、跳过2
    第2遍循环：取到3并输出、跳过4
    第3遍循环：取到回车并输出，没有更多输入，c=getchar()等待

    如果你接下来回车换行后再继续输入，这个换行符正好给了正在等待的c=getchar()，接下来再输入1又可以正常取到了。

    如果你接下来直接输入1234回车，那么1将会被正在等待的c=getchar()获取到并被跳过，接下来取到并输出的就将是2了
    */
    //for (c = getchar(); c != EOF; c = getchar()){   //这句代替上面那个for语句就是正确的程序。
        if (c == '\t')
            printf("\\t");
        else if (c == ' ')
            printf("\\b");
        else if ( c == '\\')
            printf("\\\\");
        else if (c == '\n')
            printf("\\n");   //为了更好的看清回车的行为，我多加了这句。把输入的回车显示地打印出来。
        else
            putchar(c);
    }
    return 0;
}
// */
