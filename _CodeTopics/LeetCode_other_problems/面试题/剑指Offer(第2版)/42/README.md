
`剑指 Offer 42. 连续子数组的最大和` https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/
- [x] 方法一：动态规划
- [x] 方法二：分治
  * > **思路和算法**
    + > 这个分治方法类似于「**线段树求解最长公共上升子序列问题**」的 `pushUp` 操作。也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决**多次询问**的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。
  * > **题外话**
    + > 「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？
    + > 对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 `[0, n-1]`，还可以用于解决任意的子区间 `[l,r]` 的问题。如果我们把 `[0, n-1]` 分治下去出现的***所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后***，我们就可以在 `O(logn)` 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 `O(logn)` 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。

# 测试用例

```
[-2,1,-3,4,-1,2,1,-5,4]
[1]
[0]
[-1]
[-100000]
[11,22,0,-9,8]
```
