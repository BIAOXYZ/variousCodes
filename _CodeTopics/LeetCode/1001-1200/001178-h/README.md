
`1178. 猜字谜` https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/
- [x] 方法一：二进制状态压缩
- [ ] 方法二：字典树

【详尽注释】详解「朴素位运算」& 「哈希表位运算」，以完整的优化分析思路 ... https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/xiang-jin-zhu-shi-xiang-jie-po-su-wei-yu-3cr2/
- > **位运算说明**
  * > `a >> b & 1` 代表检查 a 的第 b 位是否为 1，有两种可能性 0 或者 1
  * > `a += 1 << b` 代表将 a 的第 b 位设置为 1 (当第 b 位为 0 的时候适用)
  * > 如不想写对第 b 位为 0 的前置判断，`a += 1 << b` 也可以改成 `a |= 1 << b`
  * > PS. 1 的二进制就是最低位为 1，其他位为 0 哦
  * > 以上两个操作在位运算中出现频率超高，建议每位同学都加深理解。

「手画图解」巧用位运算，思路解析 | leetcode 1178 猜字谜 https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/shou-hua-tu-jie-si-lu-jie-xi-leetcode-11-12dy/
- 评论：
  * > 学到了
    ```console
    a = mask = "eca" = 10101

    |  a - 1  |  a = (a - 1) & mask  |
    |  10100  |  10100  = "ec"       |
    |  10011  |  10001  = "ea"       |
    |  10000  |  10000  = "e"        |
    |  01111  |  00101  = "ca"       |
    |  00100  |  00100  = "c"        |
    |  00011  |  00001  = "a"        |
    |  00000  |  end                 |
    ```

# 测试用例

```
["aaaa","asas","able","ability","actt","actor","access"]
["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
```

# 代码片段

位运算部分代码不好读，于是提出来部分，运行一下方便后面看。

```py
puzzle = 'bcde'
mask = 0
for i in range(1, 4):
    mask |= (1 << (ord(puzzle[i]) - ord("a")))
    print "mask =", mask
print "final mask is:", mask
print "\n"

subset = mask
res = []
while subset:
    s = subset | (1 << (ord(puzzle[0]) - ord("a")))
    res.append(s)
    print res
    subset = (subset - 1) & mask
    print subset
print "final res is:", res
--------------------------------------------------
mask = 4
mask = 12
mask = 28
final mask is: 28


[30]
24
[30, 26]
20
[30, 26, 22]
16
[30, 26, 22, 18]
12
[30, 26, 22, 18, 14]
8
[30, 26, 22, 18, 14, 10]
4
[30, 26, 22, 18, 14, 10, 6]
0
final res is: [30, 26, 22, 18, 14, 10, 6]
```

其实难点就是一个：为什么while循环里这句 `subset = (subset - 1) & mask` 就能遍历构造（除了空集外的）整个子集了？其实前面那个"eca"的例子就挺好了，我们给一个更general的吧：

假定位运算里代表全集的和的bit串`mask`长这个样子：`1...1...1...`（没写出来点代表的都是0）。当这个串减1后，`最低位的第一个1`（从右往左数）会因为借位变成0，然后`这个1之前的`（低位，也就是右边）`0都会变成1`，也就是会变成这样：`1...1...0111`。这俩数按位`&`后，产生变化的1的左边那些位都是不会变的，而包括这个1在内的右边的全部变成0，计算过程如下：
```console
1...1...1...
&
1...1...0111
---------------
1...1...0000
```
看，这代表了什么呢？代表了**第一个元素和第二个元素的集合**对应的bit串（`mask`什么都不变则代表了三个元素对应的比特串，也就是**集合的全集**）。

接着计算是这样的，先是`1...1...0000 - 1 = 1...01111111`，然后开始按位`&`运算：
```console
1...1...1...
&
1...01111111
---------------
1...00001...
```
这个结果代表了**第一个元素和第三个元素的集合**。

```console
1...1...1...
&
1...00000111
---------------
1...00000000
```
这个结果代表了**只有第一个元素的集合**。

```console
1...1...1...
&
011111111111
---------------
0...1...1...
```
这个结果代表了**第二个元素和第三个元素的集合**。

```console
1...1...1...
&
0...1...0111
---------------
0...1...0000
```
这个结果代表了**只有第二个元素的集合**。

```console
1...1...1...
&
0...01111111
---------------
0...0...1000
```
这个结果代表了**只有第三个元素的集合**。

最后 `0...0...1000 - 1 = 0...0...0111`，这个数和 `1...1...1...` 按位`&`操作，结果为0，循环结束。

证明： 我们不妨考虑对n个1和若干0组成的比特串这个规则都是成立的，利用数学归纳法只要证明n+1也成立即可。考虑（新的）最高位增加了一个新元素（低位或中间位增加等价于最高位增加），新的串大概是这个样子：`1...{n个1的串}`。在前面的（前一半）不断`减一，然后按位&`的过程中，新加的最高位1一直不变，其实就是后面的n个元素在重复组合成各个子集，而这些子集有个特点——是原来n个元素的子集额外加上最高位的新元素。等到最高位为1，其他全为0了，对应的是**仅有最高位一个元素的子集**。然后又是这个n个元素的子集再来一遍，只是这次不带最高位元素了。

用个具体例子来说，假如上面的`eca`已经得证，现在要证`feca`确实也能遍历全部子集，那么遍历过程是这样的：

1. 前半段有`f`时： `feca`--`fec`--`fea`--`fe`--`fca`--`fc`--`fa`--`f`
2. 后半段无`f`时： `eca`--`ec`--`ea`--`e`--`ca`--`c`--`a`--`结束`
