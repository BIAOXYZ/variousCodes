
二进制求和 https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/
- > 方法二：位运算
  ```
  如果不了解位运算，可以先了解位运算并尝试练习以下题目：

  只出现一次的数字 II
  只出现一次的数字 III
  数组中两个数的最大异或值
  重复的DNA序列
  最大单词长度乘积
  ```
- > 为什么这个方法是可行的呢？在第一轮计算中，`answer` 的最后一位是 x 和 y 相加之后的结果，`carry` 的倒数第二位是 x 和 y 最后一位相加的进位。接着每一轮中，由于 `carry` 是由 x 和 y 按位与并且左移得到的，那么最后会补零，所以在下面计算的过程中后面的数位不受影响，而每一轮都可以得到一个低 i 位的答案和它向低 i + 1 位的进位，也就模拟了加法的过程。
  ```py3
  class Solution:
    def addBinary(self, a, b) -> str:
        x, y = int(a, 2), int(b, 2)
        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry
        return bin(x)[2:]
  ```
- 个人理解：
```console
# 首先假定我们想计算 1101 + 101，也就是 13 + 5。程序的过程如下所示。我们观察发现这个算法之所以是对的，
# 原因就是把两个数的加法变成等价的两部分去做加法：
## (1) 两个数里恰好会造成进位的部分以外的数的和（对这部分求和对应程序中异或运算的代码）； 
## (2) 两个数里恰好会造成进位的部分的和（对这部分求和对应程序中与运算然后移位的代码）。
# 具体来说 1101 + 101 = (1000 + 0) + (101 + 101)；因为各自刨掉会造成进位的部分后（这里是101），
# 剩下的部分（这里是1000和0）肯定不会再有进位了，如果确定不会有进位，那么两个数求和（这里是1000和0）可以直接异或！
# 然后会造成进位的部分做与运算，等于剩下一份，再左移一位，等于乘2，其实也就是“会进位部分实际的和”。

# 此后的 1000 + 1010、10 + 10000都是类似处理，直到最后不存在能造成进位的部分，循环也就终止了。
# 为什么循环一定会终止：每次造成进位的部分加完后，造成的进位的那些1，在新一轮加法中可能造成进位也可能不造成进位，
## 总体是个小于等于递减的关系，所以终止是一定的。

// 第一轮（初始）
x = 1101 (等于 13)
y =  101 (等于 5)
answer = 1000
carry = 101
x = 1000
y = 1010

// 第二轮
1000 (等于8)
1010 (等于10)
answer = 1000 ^ 1010 = 0010 = 10
carry = 1000 & 1010 = 1000
x = 10
y = 10000

// 第三轮
10 (等于2)
10000 (等于16)
answer = 10 ^ 10000 = 10010
carry = 10 & 10000 = 0
x = 10010
y = 0

// 第四轮（结束）
x = 10010 (等于18)
y = 0 (等于0)

// 由于y已经是0，故while循环结束。
```


关于加法器：
- 加法器 https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8
- 四位计算机的原理及其实现 http://www.ruanyifeng.com/blog/2011/03/4-bit_computer.html
- 加法器原理浅析及编程模拟 https://liamlin.me/2019/06/27/the-principle-and-programming-simulation-of-binary-adder
