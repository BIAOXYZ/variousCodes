
`767. 重构字符串` https://leetcode-cn.com/problems/reorganize-string/solution/zhong-gou-zi-fu-chuan-by-leetcode-solution/
- 方法一：基于最大堆的贪心算法
- [x] 方法二：基于计数的贪心算法

# 测试用例

```
"aab"
"aaab"
"x"
"xx"
"aaabbc"
```

# `000767_ugly.py` and `000767.py`

整体思想其实就是分两部分：1)首先判断是否能达到要求，也就是是否存在某个排列使得任意相邻的字母不相同，如果不能，直接返回空串；2)如果能，那么返回符合条件的某一个排列。

对于1)，只要**出现频率最高的字母的数量**不超过`总的一半向上取整`就行了，原因是这样的：不妨假定`'a'`就是出现最多的，那么根据`'a'`的数量，先搞成下面的小格子的样子：
```console
[a...] [a...] ... [a...]
```
只要`'a'`的数量不超过`一半（向上取整）`，先把每个`'a'`占一个格子，然后剩下的字母依次往格子里填就是了。若总数是奇数，比如`5`，那么频率最高的数的数量不能超过`5/2向上取整=3`（比如`'aaabb'`可以，`'aaaab'`就不行了）；若总数是偶数，比如`6`，那么频率最高的数的数量不能超过`6/2=3`（比如`'aaabbb'`可以，`'aaaabb'`就不行了）。所以引入`math.ceil()`就不用分类讨论了——但是后来想想，应该只要把length除2前加上1，然后就用普通的除法就行了。。。

对于2)，其实就是在1)的判断方法的基础上，先申请若干个（最高频字母数）空的list，然后开始不断遍历往里填。在这之前那些丑陋的步骤都是为了把`S`处理下，主要是为了后面遍历。
