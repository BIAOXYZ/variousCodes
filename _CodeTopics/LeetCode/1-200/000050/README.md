
`50. Pow(x, n)` https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/
- [x] 方法一：快速幂 + 递归  【本质是分治算法+递归】
- [x] 方法二：快速幂 + 迭代

# 测试用例

```
2.00000
10
2.10000
3
2.00000
-2
5
0
```

# `000050_algo2.py`

这个是最常用的实现：每次除2，如果余数是1就可以进行某些操作，反之跳过该操作。

但是每次不论余数是不是1，肯定都要把n不断地除2求商。类似的题目有`1356. 根据数字二进制下 1 的数目排序`。
